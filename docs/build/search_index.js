var documenterSearchIndex = {"docs":
[{"location":"Tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"using EISAnalysis","category":"page"},{"location":"Tutorial.html#Circuit-Elements","page":"Tutorial","title":"Circuit Elements","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"This package includes Resistors, Capacitors, CPEs, Inductors, and Warburgs which can be called through the following variables:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"r, c, q, l, wo, ws","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"with default parameter values. They are all CircuitElement types. Here let's call a resistor and a capacitor","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"r","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"EISAnalysis.Resistor(1.0, Real[100000.0, 71968.5673001152, 51794.746792312115, 37275.9372031494, 26826.957952797256, 19306.977288832502, 13894.954943731376, 10000.0, 7196.85673001152, 5179.474679231211  …  0.019306977288832503, 0.013894954943731377, 0.01, 0.007196856730011521, 0.005179474679231211, 0.00372759372031494, 0.002682695795279726, 0.0019306977288832503, 0.0013894954943731376, 0.001], ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im  …  1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im])","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"c","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"EISAnalysis.Capacitor(1.0, Real[100000.0, 71968.5673001152, 51794.746792312115, 37275.9372031494, 26826.957952797256, 19306.977288832502, 13894.954943731376, 10000.0, 7196.85673001152, 5179.474679231211  …  0.019306977288832503, 0.013894954943731377, 0.01, 0.007196856730011521, 0.005179474679231211, 0.00372759372031494, 0.002682695795279726, 0.0019306977288832503, 0.0013894954943731376, 0.001], ComplexF64[0.0 - 1.0e-5im, 0.0 - 1.3894954943731376e-5im, 0.0 - 1.93069772888325e-5im, 0.0 - 2.682695795279726e-5im, 0.0 - 3.72759372031494e-5im, 0.0 - 5.179474679231211e-5im, 0.0 - 7.196856730011521e-5im, 0.0 - 0.0001im, 0.0 - 0.00013894954943731376im, 0.0 - 0.00019306977288832504im  …  0.0 - 51.79474679231211im, 0.0 - 71.9685673001152im, 0.0 - 100.0im, 0.0 - 138.94954943731375im, 0.0 - 193.06977288832502im, 0.0 - 268.2695795279726im, 0.0 - 372.759372031494im, 0.0 - 517.947467923121im, 0.0 - 719.685673001152im, 0.0 - 1000.0im])","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Each circuit element stores a frequency vector ω and its AC impedance Z over that frequency.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Now we can generate all kinds of circuits, which themselves are also CircuitElement types","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"series_circuit = r-c\nparallel_circuit = r/c\ncombined_circuit = r-r/c #can also by constructed by combined_circuit = r-parallel_circuit","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"EISAnalysis.Circuit(Real[100000.0, 71968.5673001152, 51794.746792312115, 37275.9372031494, 26826.957952797256, 19306.977288832502, 13894.954943731376, 10000.0, 7196.85673001152, 5179.474679231211  …  0.019306977288832503, 0.013894954943731377, 0.01, 0.007196856730011521, 0.005179474679231211, 0.00372759372031494, 0.002682695795279726, 0.0019306977288832503, 0.0013894954943731376, 0.001], ComplexF64[1.0000000001 - 9.999999999e-6im, 1.0000000001930698 - 1.389495494104868e-5im, 1.0000000003727594 - 1.9306977281635643e-5im, 1.0000000007196856 - 2.6826957933490283e-5im, 1.0000000013894954 - 3.727593715135466e-5im, 1.0000000026826958 - 5.179474665336256e-5im, 1.0000000051794746 - 7.196856692735584e-5im, 1.00000001 - 9.999999900000002e-5im, 1.000000019306977 - 0.000138949546754618im, 1.000000037275936 - 0.0001930697656914686im  …  1.9996273795257427 - 0.01929978311379866im, 1.9998069674958532 - 0.013892272765783583im, 1.999900009999 - 0.00999900009999im, 1.9999482079357644 - 0.007196483989945467im, 1.9999731737617137 - 0.0051793357334092675im, 1.9999861052381234 - 0.003727541926287823im, 1.9999928031950645 - 0.0026826764884413856im, 1.9999962724201745 - 0.0019306905320533472im, 1.9999980693059989 - 0.001389492811682522im, 1.999999000001 - 0.000999999000001im], Expr[:(1.0r), :(1.0r), :(1.0c)], Function[-, /], [2, 1], [1, 1, 1])","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"You can easily plot circuits using the plot_Nyquist function","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"plt = plot_Nyquist(parallel_circuit,combined_circuit)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: ) ","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"You can also set the parameters of your circuit in the following way","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"combined_circuit2 = 0.2r-1.5r/1e-02c\ncombined_circuit3 = 0.4r-r/5c\nplot_Nyquist(combined_circuit2,combined_circuit3,label = [\"circuit 1\", \"circuit 2\"])","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: ) ","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"The full list of default circuit element parameters are as follows:","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Resistor()      = 1.0r\nCapacitor()     = 1.0c\nInductor()      = 1.0l\nCPE()           = 1.0q^0.8\nWarburg(\"short\")= 1.0ws^1.0\nWarburg(\"open\") = 1.0wo^1.0","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"On top of parameters, these structs hold the complex AC impedance Z as well as the frequencies ω over which Z is evaulated","category":"page"},{"location":"Tutorial.html#Circuits","page":"Tutorial","title":"Circuits","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Circuits, which are constructed from circuit elements, store ω and Z. But they also contain the list of element expressions and operators which comprise the circuit. This enables circuits to be freely manipulated by changing parameters or changing the range of frequencies over which the impedance is calculated. Below is a quick demonstration of the ability to manipulate circuit parameters.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"circuit = 0.23r-(r-0.025wo^80)/0.2q \nprint_circuit(circuit)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"0.23r\n1.0r\n0.025 * wo ^ 80.0\n0.2 * q ^ 0.8","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"using EISAnalysis: get_params,set_params\np = get_params(circuit)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"4-element Vector{Any}:\n 0.23\n 1.0\n  (0.025, 80.0)\n  (0.2, 0.8)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"p[1] = 0.5\nupdated_circuit = set_params(circuit,p)\nprint_circuit(updated_circuit)\nplot_Nyquist(circuit,updated_circuit)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"0.5r\n1.0r\n0.025 * wo ^ 80.0\n0.2 * q ^ 0.8","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: ) ","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Furthermore, when fitting to experimental data, the ~ operator has been overloaded to do just that.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"ω_data = collect(logrange(1e-02,1e01,10))\nupdated_circuit2 = circuit ~ ω_data\nplot_Nyquist(circuit,updated_circuit2)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: ) ","category":"page"},{"location":"Tutorial.html#Circuit-Fitting","page":"Tutorial","title":"Circuit Fitting","text":"","category":"section"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"This package uses LsqFit.jl to optimize circuit parameters to fit to data. The Circuit functionalities above make it easy to build custom circuit models. Let's take an example here using Li-ion EIS data found from Mendeley Data.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"#Here is some raw LiB EIS data from Mendeley Data\nusing CSV,DataFrames,Plots\nω_exp =  [ 0.05, 0.1, 0.2, 0.4, 1, 2, 4, 10, 20, 40, 100, 200, 400, 1000]\ndata = CSV.read(\"Data/EIS_Data.csv\",DataFrame)\nZ_exp = data[!,\"Re(Z)\"]-im*data[!,\"-Im(Z)\"]\nplt =scatter(Z_exp,label = \"data\",aspect_ratio=:equal)\nplot!(plt,ylims = (-0.01,0),yflip=true)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"This data can be fit in many ways. The commonly-chosen model here is a Randles circuit. The initial guess of parameters is written directly the circuit definition.","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"randles_circuit = 0.045r-(0.02r-0.001wo^25)/2q \nplt =scatter(Z_exp,label = \"data\")\nplot_Nyquist!(plt,randles_circuit~ω_exp;label = \"initial guess\")\ndisplay(plt)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"fit = circuit_fit(randles_circuit,ω_exp,Z_exp)","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Parameters\n__________\n0.046027r\n0.021282r\n0.0010941 * wo ^ 21.839\n4.0056 * q ^ 0.65659","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"EISAnalysis.Circuit(Real[0.05, 0.1, 0.2, 0.4, 1.0, 2.0, 4.0, 10.0, 20.0, 40.0, 100.0, 200.0, 400.0, 1000.0], ComplexF64[0.07061179523546973 - 0.0036161366757002586im, 0.06954307187666481 - 0.0026715521535557504im, 0.06874379564835513 - 0.0020763517117051954im, 0.06810812559118191 - 0.0017552263613986026im, 0.06736749739341655 - 0.0017060927852878705im, 0.066764686487546 - 0.0019573565714202266im, 0.06599895839171742 - 0.0024813832147565526im, 0.06446508247644935 - 0.0036020266237018496im, 0.06265958883350577 - 0.004664502602918982im, 0.06015344812037913 - 0.005620471222819887im, 0.05606188291759614 - 0.006049061177104257im, 0.053034945917901526 - 0.005501458630241011im, 0.05060616191363954 - 0.004454884628732528im, 0.048497540869868086 - 0.0029615176982271175im], Any[:(0.046027r ~ [0.05, 0.1, 0.2, 0.4, 1.0, 2.0, 4.0, 10.0, 20.0, 40.0, 100.0, 200.0, 400.0, 1000.0]), :(0.021282r ~ [0.05, 0.1, 0.2, 0.4, 1.0, 2.0, 4.0, 10.0, 20.0, 40.0, 100.0, 200.0, 400.0, 1000.0]), :(0.0010941 * wo ^ 21.839 ~ [0.05, 0.1, 0.2, 0.4, 1.0, 2.0, 4.0, 10.0, 20.0, 40.0, 100.0, 200.0, 400.0, 1000.0]), :(4.0056 * q ^ 0.65659 ~ [0.05, 0.1, 0.2, 0.4, 1.0, 2.0, 4.0, 10.0, 20.0, 40.0, 100.0, 200.0, 400.0, 1000.0])], Function[-, -, /], [3, 1, 2], [1, 1, 1, 1])","category":"page"},{"location":"Tutorial.html","page":"Tutorial","title":"Tutorial","text":"Whether a randles circuit is the best model for this particular dataset is a different story. This same data can be fit using compute_drt(), which is demonstrated in the DRT notebook.","category":"page"},{"location":"api.html#Detailed-API","page":"API","title":"Detailed API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [EISAnalysis]\nOrder   = [:function]","category":"page"},{"location":"api.html#Base.:*-Tuple{Real, EISAnalysis.Resistor}","page":"API","title":"Base.:*","text":"Base.*(a::Real,b::CircuitElement)\n\nMutates the impedance parameter of CircuitElements.\n\nArguments\n\na::Real: Impedance parameter value\nb::CircuiElement: Circuit element \n\n#Examples\n\njulia> eval(initialize());\njulia> r.R\n1.0\njulia> twor = 2r;\njulia> twor.R\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.:--Tuple{EISAnalysis.CircuitElement, EISAnalysis.Circuit}","page":"API","title":"Base.:-","text":"-(a::Union{Circuit,CircuitElement},b::Union{Circuit,CircuitElement})\n\nHolds the inputs in series and generates a Circuit.\n\nOperates over Circuits and CircuitElements.\n\nArguments\n\na::Union{Circuit,CircuitElement}: circuit or circuit element to hold in series with b\nb::Union{Circuit,CircuitElement}: circuit or circuit element to hold in series with a\n\n#Examples\n\njulia> eval(initialize());\njulia> circuit1 = r-c;\njulia> circuit2 = circuit1-c;\njulia> circuit2.Z == (r-c-c).Z == (r-0.5c).Z\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.:/-Tuple{EISAnalysis.CircuitElement, EISAnalysis.Circuit}","page":"API","title":"Base.:/","text":"Base./(a::Union{Circuit,CircuitElement},b::Union{Circuit,CircuitElement})\n\nHolds the inputs in parallel and generates a Circuit.\n\nOperates over Circuits and CircuitElements.\n\nArguments\n\na::Union{Circuit,CircuitElement}: circuit or circuit element to hold in parallel with b\nb::Union{Circuit,CircuitElement}: circuit or circuit element to hold in parallel with a\n\n#Examples\n\njulia> eval(initialize());\njulia> circuit1 = r/c;\njulia> circuit1.elements\n2-element Vector{Expr}:\n :(1.0r)\n :(1.0c)\njulia> circuit2 = circuit1/c;\njulia> circuit2.Z == ((r/c)/c).Z\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.:^-Tuple{EISAnalysis.CPE, Real}","page":"API","title":"Base.:^","text":"Base.^(a::CircuitElement,b::Real)\n\nMutates the exponent parameter of CPE's and Warburgs.\n\nArguments\n\na::CircuiElement: circuit or circuit element to hold in series with a\nb::Real: Exponential parameter value\n\n#Examples\n\njulia> eval(initialize());\njulia> circuit = q-wo; print_circuit(circuit)\n1.0 * q ^ 0.8\n1.0 * wo ^ 1.0\njulia> circuit2 = q^0.6-wo^5; print_circuit(circuit2)\n1.0 * q ^ 0.6\n1.0 * wo ^ 5.0\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.:~-Tuple{EISAnalysis.Resistor, Vector{Float64}}","page":"API","title":"Base.:~","text":"Base.~(a::Union{CircuitElement,Circuit},ω::Vector{Float64})\n\nMaps the frequencies over which impedance is calculated to the desired frequency.\n\nOperates over Circuits and CircuitElements.\n\nArguments\n\n-a: Circuit element or circuit -ω: Frequencies to map to\n\nExamples\n\njulia> ω = [0.1,1,10]\n3-element Vector{Float64}:\n  0.1\n  1.0\n 10.0\njulia> eval(initialize());\njulia> circuit = r/c ~ω; println(circuit.ω,circuit.Z)\nReal[0.1, 1.0, 10.0]ComplexF64[0.9900990099009901 - 0.09900990099009901im, 0.5 - 0.5im, 0.009900990099009903 - 0.09900990099009901im]\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.build_Z_matrices-Tuple{Any, Any}","page":"API","title":"EISAnalysis.build_Z_matrices","text":"build_Z_matrices(ω_in,ω_out)\n\nBuilds the matrices (real + imaginary) through which impedance is calculated.\n\nSee compute_drt, optimize_lambda, and tune_τ\n\n#Attributes\n\nω_in: The input EIS frequencies\nω_out: he desired output frequencies for computing DRT\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.circuit_fit-Tuple{Any, Any, Any}","page":"API","title":"EISAnalysis.circuit_fit","text":"circuit_fit(circuit, ω_data,Z_data)\n\nMain function for fitting a Circuit to EIS data.\n\nThe initial guess is passed implicitly through the circuit definition. E.g.     randles_circuit = 0.23r-(r-0.025wo^80)/0.2c     # p0 = [0.23,1.0,(0.025,80),0.2]\n\nAttributes\n\ncircuit: Circuit for fitting\nω_data: EIS frequencies\nZ_data: EIS impedance\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.compute_drt-Tuple{Any, Any}","page":"API","title":"EISAnalysis.compute_drt","text":"compute_drt(ω_exp,Z_exp;ppd,showplot,rtol,regularization)\n\nMain function for computing the DRT from input EIS data.\n\nAttributes\n\nω_exp: Input EIS frequency\nZ_exp: Input EIS Impedance\nppd=7: Points-per-decade in output τ range for computing DRT\nshowplot=false: Whether or not to plot DRT results\nrtol=1e-03: The desired relative tolerance. Function outputs a warning if the fit result is above this\nregularization=false: Whether or no to employ the regularization method\n\nExamples\n\njulia> ω_exp, Z_exp = (r/q).ω, (r/q).Z; #replace this with actual data;\njulia> fit = compute_drt(ω_exp,Z_exp;showplot = false,regularization = true)\nRegularization\n--------------\nλ = 1.0e-6\nrerror = 1.0372641378584664e-5\nDict{String, Any} with 4 entries:\n  \"Z\"   => ComplexF64[3.05534e-5-9.31279e-5im, 3.93483e-5-0.000122541im, 5.13691e-5-0.000160629im, 6.74522e-5-0.000209759im, 8.85396e-5-0.000273092im, 0.000115777-0.000354963im, 0.00015081-0.000461241im,…\n  \"τ\"   => LogRange{Float64}(1.0e-6, 10000.0, 70)\n  \"R0\"  => 5.69325e-6\n  \"drt\" => [6.50295e-6, 6.38765e-6, 6.18446e-6, 5.82042e-6, 5.16761e-6, 4.02587e-6, 2.15302e-6, 2.46489e-5, 1.9091e-5, 3.48558e-5  …  0.00138043, 0.00116424, 0.0, 0.0, 0.00282261, 0.0, 0.0, 0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.drt_Z-Tuple{Any, Any, Any}","page":"API","title":"EISAnalysis.drt_Z","text":"drt_Z(X_r,X_i,p)\n\nUses Z matrices to compute impedance for least-squares fit.\n\nAttributes\n\nX_r: The real Z matrix for computing impedance\nX_i: The imaginary Z matrix for computing impedance\np: The parameter list\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.drt_Z_regular-NTuple{6, Any}","page":"API","title":"EISAnalysis.drt_Z_regular","text":"drt_Z_regular(X_r,X_i,Y_r,Y_i,λ,p_reg)\n\nSee drt_Z. Incorporates regularization in least-squares minimization.\n\nSince LsqFit minimizes Σ|Xᵢ-Yᵢ|², this function generates A such that     |Aᵢ-Yᵢ|² = |Xᵢ-Yᵢ|² + (λ/N)|p|²     Aᵢ = Yᵢ+√(|Xᵢ-Yᵢ|²+(λ/N)|p|²) where N is the length of the vectors. Since the Real component carries  the extra parameter (R0), two different functionsare defined for the real  and imaginary components.Used for regularization method of computing DRT.\n\nAttributes\n\nX_r: The real Z matrix for computing impedance\nX_i: The imaginary Z matrix for computing impedance\nY_r: The real component of input impedance data\nY_i: The imaginary component of input impedance data\nλ: The regularization hyperparameter\np_reg: The parameter list\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.drt_Zimag_regular-NTuple{4, Any}","page":"API","title":"EISAnalysis.drt_Zimag_regular","text":"drt_Zimag_regular(X_i,Y_i,λ,p_reg)\n\nSee drt_Z_regular. Outputs the imaginary component.\n\nThe only difference with drtZrealregular() is ignoring the series resistance. Used for crossvalidation in optimize_lambda.\n\nAttributes\n\nX_i: The imaginary Z matrix for computing impedance\nY_i: The imaginary component of input impedance data\nλ: The regularization hyperparameter\np_reg: The parameter list\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.drt_Zreal_regular-NTuple{4, Any}","page":"API","title":"EISAnalysis.drt_Zreal_regular","text":"drt_Zreal_regular(X_r,Y_r,λ,p_reg)\n\nSee drt_Z_regular. Outputs the real component.\n\nUsed for crossvalidation in optimize_lambda.\n\nAttributes\n\nX_r: The real Z matrix for computing impedance\nY_r: The real component of input impedance data\nλ: The regularization hyperparameter\np_reg: The parameter list\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.evaluate_Z-Tuple{Any, Any}","page":"API","title":"EISAnalysis.evaluate_Z","text":"evaluate_Z(f_r,f_c)\n\nComputes elements for Z_matrices. The function based on impedance of an RC Circuit\n\nArguments\n\nf_r: The Z_matrix row frequency\nf_c: The Z_matrix column frequency\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.get_params-Tuple{EISAnalysis.Resistor}","page":"API","title":"EISAnalysis.get_params","text":"get_params(a::Union{CircuitElement,Circuit})\n\nGets the parameters for elements in a circuit.\n\nAttributes\n\na::Union{CircuitElement,Circuit}: The circuit or circuit element\n\nExamples\n\njulia> eval(initialize());\njulia> randles_circuit = 0.23r-(r-0.025wo^80)/0.2q;\njulia> p = get_params(randles_circuit)\n4-element Vector{Any}:\n 0.23\n 1.0\n  (0.025, 80.0)\n  (0.2, 0.8)\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.get_subcircuit-Tuple{Any, Any, Any}","page":"API","title":"EISAnalysis.get_subcircuit","text":"get_subcircuit(subelements,suboperators,suborder)\n\nCreates a circuit from a subcircuit.\n\nUsed in rebuild. Currently a bit sloppy.\n\nAttributes\n\nsubelements: elements of subcircuit\nsuboperators: operators of subcircuit\nsuborder: operation order of subcircuit\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.get_symbol-Tuple{EISAnalysis.Resistor}","page":"API","title":"EISAnalysis.get_symbol","text":"get_symbol(a::CircuitElement)\n\nCreates the symbol (technically expressions) for a circuit element, using globally defined variables.\n\nUsed for generating the elements field of a circuit.\n\nAttributes\n\na::CircuitElement: The circuit element\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.initialize-Tuple{}","page":"API","title":"EISAnalysis.initialize","text":"initialize()\n\nGenerates all the circuit elements for ease of use in building circuits.\n\nIt adds the following variables to your environment     r = Resistor()     c = Capacitor()     l = Inductor()     q = CPE()     wo = Warburg(\"open\")     ws = Warburg(\"short\") From here you can quickly build circuits and adjust the parameters directly  using the overloaded * and ^ operators as desired\n\nExamples\n\njulia> eval(initialize());\njulia> silly_circuit = 0.25r/2.5l-(r-9wo)/q^0.64-(16r-ws^144)/12.1c;\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.optimize_lambda-Tuple{Any, Any, Any}","page":"API","title":"EISAnalysis.optimize_lambda","text":"optimize_lambda(ω_exp,Z_exp,τ)\n\nGenerates the optimal regularization hyperparameter for compute_drt.\n\nAttributes\n\nω_exp: Input EIS frequency\nZ_exp: Input EIS Impedance\nτ: Desired relaxation times for computing DRT: generated in compute_drt\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.plot_Nyquist!-Tuple{Any, Vararg{EISAnalysis.Circuit}}","page":"API","title":"EISAnalysis.plot_Nyquist!","text":"plot_Nyquist!(plt,a;label)\n\nAdds circuits to pre-existing Nyquist plot\n\nArguments\n\nplt: The input Nyquist plot to manipulate\na::Circuit: The circuits to add to the Nyquist plot\nlabel: kwarg label for plot\n\nExamples\n\njulia> circuit1 = r-r/c;\njulia> circuit2 = r-r/q;\njulia> plot_Nyquist(circuit1,circuit2;label= [\"R-C Circuit\",\"R-CPE Circuit\"]);\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.plot_Nyquist-Tuple{Vararg{EISAnalysis.Circuit}}","page":"API","title":"EISAnalysis.plot_Nyquist","text":"plot_Nyquist(a;label)\n\nCreates a Nyquist plot\n\nArguments\n\na::Circuit: The circuits to add to the Nyquist plot\nlabel: kwarg label for plot\n\nExamples\n\njulia> circuit1 = r-r/c;\njulia> circuit2 = r-r/q;\njulia> plot_Nyquist(circuit1,circuit2;label= [\"R-C Circuit\",\"R-CPE Circuit\"]);\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.print_circuit-Tuple{Any}","page":"API","title":"EISAnalysis.print_circuit","text":"print_circuit(circuit)\n\nPrints the elements of a circuit along with its parameters\n\nArguments\n\ncircuit::Circuit: The circuit being printed\n\nExamples\n\njulia> randles_circuit = 0.23r-(r-0.025wo^80)/0.2q;\njulia> print_circuit(randles_circuit)\n0.23r\n1.0r\n0.025 * wo ^ 80.0\n0.2 * q ^ 0.8\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.rebuild-Tuple{Any}","page":"API","title":"EISAnalysis.rebuild","text":"rebuild(circuit::Circuit)\n\nMain function for recalculating a circuit's impedance.\n\nUsed after mutating a circuit through either ~ or set_params\n\nAttributes\n\ncircuit: Mutated circuit to be rebuilt\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.regularizer-Tuple{Any, Any}","page":"API","title":"EISAnalysis.regularizer","text":"regularizer(p,λ)\n\nComputes the regularization of parameters. Used in regularization method of computing DRT.\n\nSee drt_Z_regular,drt_Zimag_regular, and drt_Zreal_regular\n\n#Arguments\n\np: The parameter list \nλ: Regularization hyperparameter\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.set_params-Tuple{EISAnalysis.Resistor, Any}","page":"API","title":"EISAnalysis.set_params","text":"set_params(a::Union{CircuitElement,Circuit})\n\nSets the parameters for elements in a circuit. \n\nCurrently a bit sloppy.Used in circuit_fit\n\nAttributes\n\na::Union{CircuitElement,Circuit}: The circuit or circuit element\np: The parameter list. Needs to carry tuples for elements with two parameters\n\nExamples\n\njulia> eval(initialize());\njulia> circuit = r-r/q;\njulia> p = [0.5,2,(0.5,0.9)]\n3-element Vector{Any}:\n 0.5\n 2\n  (0.5, 0.9)\njulia> updated_circuit = EISAnalysis.set_params(circuit,p); print_circuit(updated_circuit)\n0.5r\n2.0r\n0.5 * q ^ 0.9\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.tune_τ-Tuple{Any, Any}","page":"API","title":"EISAnalysis.tune_τ","text":"tune_τ(ω_exp,Z_exp;ppd,tol)\n\nGenerates the optimal τ range for computing DRT.\n\nCurrently incomplete. Would be used in compute_drt\n\nAttributes\n\nω_exp: Input EIS frequency\nZ_exp: Input EIS Impedance\nppd: Points-per-decade in output τ range for computing DRT\ntol=1e-03: Tolerance for finding τ bounds where DRT impedance is sufficiently small\n\n\n\n\n\n","category":"method"},{"location":"api.html#EISAnalysis.unflatten_parameters-Tuple{Any, Any}","page":"API","title":"EISAnalysis.unflatten_parameters","text":"unflatten_parameters(pflat,tuples)\n\nShapes parameter list to feed into Circuit. See circuit_fit\n\nLsqFit.curvefit requires a parameter list that is flat, but setparams may require a parameter list with tuples. This function unflattens parameter list to feed to set_params.\n\nAttributes\n\npflat: Flat parameter list\ntuples: List of tuple indices for unflattened parameter list\n\n\n\n\n\n","category":"method"},{"location":"DRT.html#Calculating-DRT","page":"DRT","title":"Calculating DRT","text":"","category":"section"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"This package estimates DRT by generating a Voigt circuit model and fitting its parameters using LsqFit.jl. The concept can be broken down simply: any impedance Z(omega) can be generated by a series of RC pairs: $ Z(\\omega) = \\sumi^\\infty \\frac{Ri}{1+i\\omega\\taui},\\ \\taui = RiCi $ This is analogous to a fourier transform for generic functions. Let's look at some examples.","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"using EISAnalysis","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"First, let's consider a simple circuit with 2 RC pairs","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"rc_circuit = r/c-1.2r/5c\nplot_Nyquist(rc_circuit)","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"(Image: )","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"You can fit this to a Voigt circuit and estimate the DRT. The expanded fit includes the individual contribution from each RC pair in the Voigt circuit model and acts as a visual aid in interpreting the DRT plot.","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"rc_fit = compute_drt(rc_circuit.ω,rc_circuit.Z)","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"(Image: )","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"Dict{String, Any} with 4 entries:\n  \"Z\"   => ComplexF64[3.94376e-5-0.000121343im, 5.13126e-5-0.000157868im, 6.676…\n  \"τ\"   => LogRange{Float64}(1.0e-6, 10000.0, 70)\n  \"R0\"  => 1.80035e-6\n  \"drt\" => [1.7049e-5, 7.79661e-7, 9.44932e-7, 1.6376e-5, 0.0, 2.68542e-5, 8.40…","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"Now for more complicated circuits, it is helpful to employ Tikhonov regularization to decouple parameters. However, one has to be carefel when interpreting this data. Notice the high frequency (low timescale) bump in the fit as well as the DRT. This is an artifact from the regularization method. It's always helpful to see the results both with and without regularization to check for such artifacts.","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"In general, computing the DRT is problematic when the EIS frequency range is too narrow and the Nyquist plot is not fully resolved (especially on the high frequency end). In such cases it is safer to use circuit_fit.","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"randles_circuit = 0.23r-(r-0.025ws^80)/0.2q\nrandles_fit = compute_drt(randles_circuit.ω,randles_circuit.Z;regularization=true)","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"Regularization\n--------------\nλ = 9.999999999999999e-5\nrtol = 0.0005431364784255923","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"(Image: )","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"Dict{String, Any} with 4 entries:\n  \"Z\"   => ComplexF64[0.225575-0.0277721im, 0.228226-0.0205447im, 0.229664-0.01…\n  \"τ\"   => LogRange{Float64}(1.0e-6, 10000.0, 70)\n  \"R0\"  => 0.0648194\n  \"drt\" => [0.150936, 0.133404, 0.108899, 0.075177, 0.0303512, 0.0, 0.0, 0.0, 0…","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"With this experimental EIS data from Mendeley, the issue discussed above is further demonstrated. ","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"using CSV,DataFrames,Plots\nω_exp =  [ 0.05, 0.1, 0.2, 0.4, 1, 2, 4, 10, 20, 40, 100, 200, 400, 1000]\ndata = CSV.read(\"Data/EIS_Data.csv\",DataFrame)\nZ_exp = data[!,\"Re(Z)\"]-im*data[!,\"-Im(Z)\"]\nplt =scatter(Z_exp,label = \"data\",aspect_ratio=:equal)\nplot!(plt,ylims = (-0.01,0),yflip=true)","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"(Image: )","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"Without using regularization we may have a good DRT firt but may wish to use regularization to decouple the parameters and generate a smoother function. However the drt computed with regularization generates a model that does not fit at all to the original data set. This is principally owed to the unresolved feature of the original Nyquist plot in the high frequency range. In this case it could me more useful to fit the data to a circuit model like a Randles circuit.","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"fit = compute_drt(ω_exp,Z_exp)\nregularized_fit = compute_drt(ω_exp,Z_exp;regularization=true)","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"rtol = 5.899319460523529e-7\nRegularization\n--------------\nλ = 0.01\nrtol = 0.0008280857326777196","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"(Image: ) (Image: )","category":"page"},{"location":"DRT.html","page":"DRT","title":"DRT","text":"Dict{String, Any} with 4 entries:\n  \"Z\"   => ComplexF64[0.0706284-0.00414218im, 0.0692506-0.00274757im, 0.0686266…\n  \"τ\"   => LogRange{Float64}(0.0001, 200.0, 42)\n  \"R0\"  => 0.0124534\n  \"drt\" => [0.0293391, 0.0267395, 0.022969, 0.0175789, 0.0102225, 0.00129367, 0…","category":"page"},{"location":"index.html#EISAnalysis.jl","page":"Index","title":"EISAnalysis.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Documentation for EISAnalysis.jl","category":"page"}]
}
